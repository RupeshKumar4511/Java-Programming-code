# Java-Programming

# Overview of JAVA
Intially Java was developed by James Gosling and his team in 1991 at Sun microsystem (company) and this company released its first implementation in 1996
as java 1.0 .

# JAVA as plateform -Independent
Every Java program is firstly compiled by javac compiler(present in JDK) and it generates a byte code and this byte code can be executed by JVM on all Operating System because Every Computer System has diffent a different operating System but the output generated by all the operating system is same.
That's why java is called Plateform independent.

# Features of Java
1. Simple : Because it is easy to learn and its syntax is very simple.
<br>
2. Object Oriented : Java is an object-oriented programming language.Object-oriented means we organize our application programs as a combination of different types of objects that incorporate both data and behavior.Everything in java is represented in Class as an object including the main function.

<br>

3.Secured : 
Java is best known for its security. With Java, we can develop virus-free systems. Java is secured because:
<br>
No explicit pointer
Java Programs run inside a virtual machine sandbox
<br>

Classloader: Classloader in Java is a part of the Java Runtime Environment (JRE) which is used to load Java classes into the Java Virtual Machine dynamically. It adds security by separating the package for the classes of the local file system from those that are imported from network sources.
<br>
Bytecode Verifier: It checks the code fragments for illegal code that can violate access rights to objects.
Security Manager: It determines what resources a class can access such as reading and writing to the local disk.

<br>

4.Plateform Independent
<br>

5.Portable:
Java is portable because it facilitates you to carry the Java bytecode to any platform. It doesn't require any implementation.
<br>
6. Java is both compiled and interpreted language.
<br>
The source code we write in Java is first compiled into bytecode during the build process. The JVM then interprets the generated bytecode into machine code for execution. However, the JVM also makes use of a JIT compiler during runtime to improve performances.
<br>
7. Multithreading:  Java supports multithreading. It is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of the CPU.
<br>
8.Robust:  Java language is robust which means reliable. It is developed in such a way that it puts a lot of effort into checking errors as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming language. The main features of java that make it robust are garbage collection, Exception Handling, and memory allocation.



# Garbage Collection
Garbage collection in Java is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory.

<br>



Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.
<br>
public void finalize() {
} 
<br>
This method is used for to perform cleanup activities before the destructiion of Objects.

# Working of Compiler
![image](https://github.com/RupeshKumar4511/Java-Programming-code/assets/149661006/59cd432e-a0b0-4910-9e7c-2ecf9d2c93a8)

# JVM Archietecture 
![image](https://github.com/RupeshKumar4511/Java-Programming-code/assets/149661006/5df0c4de-2250-420f-8769-22628b455283)

# Cross-platform 
It is the ability of software applications to operate on multiple operating systems (OS).

# JDK ,JRE ,JVM
JDK = Java Development Kit is a cross plateform  Software development environment that consists of JRE and Developments(javac compiler and other tools) which are necessary for developing java based Software Application.
JRE = Java Runtime Environment consists of JVM and Set of Libraries and other files which provides the environment for executing the Java Program.
JVM = Java virtual machine is responsible for executing the byte code of Java program.


# JIT (Just In Time) compiler in JVM:
The main disadvantage of an interpreter is that every time a method is called, it requires interpretation, which can be slower than compiled native code. Java makes use of the JIT compiler to overcome this issue.
The JIT compiler doesn’t completely replace the interpreter. The execution engine still uses it. However, the JVM uses the JIT compiler based on how frequently a method is called.
<br>
The JIT compiler compiles the entire method’s bytecode or(we can say reusable byte code) to machine native code.so that it can be reused directly.


# Byte code:
It is an intermediate code between Source code and Machine code.

# Machine code : 
It is set of Instruction that is directly understandable to machine and processed by cpu.


# Antanomy of java
When thejVM starts running, it looks for the class you give it at the command line. Then it starts looking for a specially-Written method that looks
exactly like:
<br>
public static void main (String [] args){

// your code goes here
}
<br>
Next, theJVM runs everything between the curly braces { }of your main
method.
<br>
**EveryJava application has to have at least one class. and at least
one main method (not one main per class;just one main per application**).


# class and Object
![image](https://github.com/RupeshKumar4511/Java-Programming-code/assets/149661006/dab63228-4e62-46ab-bdcf-5e267c283ab0)


**A class is not an object.
(but it’s used to construct them)**


**Object**


Object is a collection of state(variables ) and behavior ( method)


 **Class** 
 <br>
 A class is blue print of an  object.
 <br>
 
It tells virtual machine how to make an object of that type . Each object made from that class have its own value for the instance variable ov that class.


# Use of main method:

1. To test your real class
<br>

2.To launch/start your Java application


# Know about the basic syntax keywords:
Java makes main method static so that JVM can call it without create an object for that class that contains main method.

<br>

String[] args : This is used to signify that the user may opt to enter parameters to the Java Program at command line.


# Important Point from Data Type:
Remember: In Java SE 8 and later, we can use the int data type to represent an unsigned 32-bit integer, which has a value in the range [0, 2 raise to power 32-1]. Use the Integer class to use the int data type as an unsigned integer. 
<br>

Remember: In Java SE 8 and later, you can use the long data type to represent an unsigned 64-bit long, which has a minimum value of 0 and a maximum value of 2 raise to power 64-1. The Long class also contains methods like comparing Unsigned, divide Unsigned, etc to support arithmetic operations for unsigned long. 

<br>

example=>
``` bash
    byte a = -20;
    byte b = -30;
    System.out.println(Byte.toUnsignedInt(a)); // 236
    // binary no of 20 = 00010100 (three zerro added to make 1 byte)
    // two's complement of 20 => 11101100 => 236

    System.out.println(Integer.toUnsignedLong(a)); // 4294967276
    // two's complement of -30 for long datatype

    System.out.println(Integer.toUnsignedLong(b)); // 4294967266

    System.out.println(Integer.divideUnsigned(a, b)); // 1
    // this is what happened in this code
    // public static int divideUnsigned(int dividend, int divisor) {
    // return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));
    // }
```


# why size of char is 2 bytes in java?
Java uses the Unicode system not the ASCII code System and to represent the Unicode system 8 bits is not enough to represent all characters so Java uses 2 bytes for characters.


# Enum :
Enum is like a class which is used to define a set of fixed constants.

An enum can, just like a class, have attributes and methods. The only difference is that enum constants are public, static and final (unchangeable - cannot be overridden).
<br>
An enum cannot be used to create objects, and it cannot extend other classes (but it can implement interfaces).
<br>
Why And When To Use Enums?
<br>
Use enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.
<br>
Example =>
<br>
// A Java program to demonstrate that we can have
// main() inside enum class.
```bash

enum Level {
  LOW,
  MEDIUM,
  HIGH
}

public class Main { 
  public static void main(String[] args) { 
    Level myVar = Level.MEDIUM; 
    System.out.println(myVar); 
  } 
}
```
# Keywords:
There are 67 keywords and 3 literals in java.
<br>
Literals: true ,false ,null
<br>
Note: The keywords const and goto are reserved, even though they are not currently used. In place of const, the final keyword is used. Some keywords like strictfp are included in later versions of Java.

<br>

# Operators:
Operators are special symbol that are used for performing certain function.
# Presendence in operators:
In unary and assignment operator the associativity is from right to left.
<br>
In all other operator the associativity is from left to right.

#  Concatenation:
 int x =3;
 int y =5;
 <br>
 System.out.println("Concatenation (x+y)= " + x + y); // Concatenation of (x+y) = 35
# Addition:
  System.out.println("Addition (x+y) = " + (x + y)); // Addition of (x+y) =  8

# Variable :
Variable is name given to memory given to memory location.

# Important point about static variable:
1.If we access a static variable like an instance variable (through an object), the compiler will show a warning message, which won’t halt the program. The compiler will replace the object name with the class name automatically.
<br>

<br>

2.If we access a static variable without the class name, the compiler will automatically append the class name. But for accessing the static variable of a different class, we must mention the class name as 2 different classes might have a static variable with the same name.

<br>
<br>
3. Value of static variable can be changed inside another static or non static method in a class .But static variable get memory only once.
<br>
<br>
4.Static variables and their values (both primitives and references) are stored in the Metaspace.


# Important point about instance variable:
Instance variables are stored in the heap memory as part of the objects they belong to.

# Instance method :
Instance methods are methods that require an object of its class to be created before it can be called.
<br>
<br>
**Important Point  :**  Instance methods are stored in metaspace.

# Static method :
Static methods are the methods in Java that can be called without creating an object of class.
<br>
<br>
Static methods are stored in Metaspace .
# Important point about abstract variable:
 The following are various illegal combinations of other modifiers for methods with respect to abstract modifiers:
 <br>
final abstract
<br>
abstract native
<br>
abstract synchronized
<br>
abstract static
<br>
abstract private
<br>
abstract strictfp
<br>
# Loop Variables (Block Scope) :
A variable declared inside pair of brackets “{” and “}” in a method has scope within the brackets only.
<br>
``` bash
public class Test
{
    public static void main(String args[])
    {
        {
            // The variable x has scope within
            // brackets
            int x = 10;
            System.out.println(x);
        }
        
        // Uncommenting below line would produce
        // error since variable x is out of scope.

        // System.out.println(x); 
    }
}
```


# Important Point from loop variable:
 The name of the variable of inner and outer loop must be different.

``` bash
class Test
{
    public static void main(String args[])
    {
        {
            int x = 5;
            {
                int x = 10;
                System.out.println(x);
            }
        }
    }
}
```
<br>
// this code shows error because variable name of innner and outer loop is same.
<br>
Note : For a variable to be read after the termination of a loop, It must be declared before the body of the loop.



# Methods to Take Input in Java
There are two ways by which we can take Java input from the user or from a file
<br>
1.BufferedReader Class
<br>
2.Scanner Class
<br>
3.Using console
<br>
// Using Console to input data from user
<br>
String name = System.console().readLine();

# important point from Scanner class and BufferReader class:
The Scanner class reads an entire line and divides the line into tokens. Tokens are small elements that have some meaning to the Java compiler. For example, Suppose there is an input string: How are you
In this case, the scanner object will read the entire line and divides the string into tokens: “How”, “are” and “you”. The object then iterates over each token and reads each token using its different methods.
<br>
But BufferReader Reads text from a character-input stream (simply reads sequence of character ). That's why it is faster than Scanner class.
<br>
BufferReader class always wraps around FileReader class(in case of Text file) or InputStreamReader (in case of taking input from keyboad).
``` bash

public class Test
{
  
    public static void main(String args[]) 
    {
        try{
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String str = br.readLine();
            System.out.println(str);
            
        }
    catch(Exception e){
     System.out.println(e);
    }
        
    }
}
```
<br>

# InputStreamReader 
It reads bytes and decodes them into characters using a specified charset.

# Parts of System.out.println()
The statement can be broken into 3 parts which can be understood separately:
<br>

System: It is a final class defined in the java.lang package.
<br>
out: This is an instance of PrintStream type, which is a public and static member field of the System class.
<br>
println(): As all instances of the PrintStream class have a public method println().
<br>



# if statement:
If is a decision making statement which tells that if condition is true then  block of code inside if statement will be executed.
<br>
Note : If we do not provide the curly braces ‘{‘ and ‘}’ after if( condition ) then by default if statement will consider the immediate one statement to be inside its block.

# if-else:
If-else is also a decision making statement which tells that if a condition is true then  block of code inside if statement will be executed otherwise else block of code  will be executed.

# Nested if :
If statement inside another if statement is called Nested if Statement. It is used when we want to take decision on multiple conditions.

# if-else-if :
If-else-if is also a decision making statement which is used when we want to take multiple decision on multiple coditions.

# switch case:
switch case is used to make choice between number of alternatives for a given variable.

# Loops:
while loop: A while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition.
It is condition controlled loop .
Note:
```bash
while(true){
}
//This is used to ceate infinite loop.
```
<br> <br>

For loop : A for loop is a control flow statemnt that allows code to be executed repeatedly for a specified no of times.
It is count controlled loop.
<br>
we can also provide label to for loop.
<br>
example =>
label1:for(int i =0; i<5;i++){};
<br> <br>
do while : do while loop is similar to while loop except the fact that it is guaranted to execute atleast once.
It executes the code once and then checks the conditions.
<br>

# Jumping Statement
1.Break => break is used to exit from the loop irrespective of whether the condition is true or not.It is also knowns as loop control statement.
<br>
2.Continue => continue is used to skip rest of current iteration continue to next iteration of the loop.It is also knowns as loop control statement.
<br>
3.Return => The return statement is used to explicitly return from a method. That is, it causes program control to transfer back to the caller of the method.
example =>
``` bash
// Java program to illustrate using return
import java.util.*;

public class Return {
	public static void main(String args[])
	{
		boolean t = true;
		System.out.println("Before the return.");

		if (t)
			return;

		// Compiler will bypass every statement
		// after return
		System.out.println("This won't execute.");


	}
}
// output = Before the return.
```

# Infinite for loop:
``` bash

import java.io.*;

class GFG {
	public static void main(String[] args)
	{
		for (;;) {
		}
	}
}
```

# Important point from label loop:
``` bash
// Java program to illustrate 
// using break with goto
class BreakLabelDemo {
    public static void main(String args[])
    {
        boolean t = true;

    // label first
    first : {
      
    // Illegal statement here 
    // as label second is not
    // introduced yet break second;
    second : {
    third : {
        // Before break
        System.out.println("Before the break statement");

        // break will take the control out of
        // second label
        if (t)
            break second;
        System.out.println("This won't execute.");
    }
        System.out.println("This won't execute.");
    }

        // First block
        System.out.println("This is after second block.");
    }
    }
}
// output = Before the break statement.
This is after second block.
```


<br> <br>
``` bash
// Java program to illustrate usage of
// statement after return statement

// Main class
class GFG {

    // Since return type of demofunction method is void
    // so this method should return any value
    // Method 1
    void demofunction(double j)
    {
        return;

        // Here get compile error since can't
        // write any statement after return keyword

        ++j;
    }

    // Method 2
    // Main driver method
    public static void main(String[] args)
    {

        // Calling the above defined function
        new GFG().demofunction(5);
    }
}
```
# how to use for else in java ;
``` bash
int num =25;
boolean found = false;
for(int i =2;i<num;i++){
if (num % i==0){
  found = true;
  
  System.out.println("not prime number");
  break;
} 
}
if (!found){
  System.out.println("prime number");

}

```
# Strings :

**CharSequence Interface :**
<br>
CharSequence Interface is used for representing the sequence of Characters in Java.
<br>
Classes that are implemented using the CharSequence interface are:
<br>
1.String
<br>
2.StringBuffer
<br>
3.StringBuilder
<br>


**String** is a sequence of characters.Strings are the type of objects that can store the character of values and in Java, every character is stored in 16 bits i.e using UTF 16-bit encoding. A string acts the same as an array of characters in Java.String is also thread safe.

<br>

**Important Point :** String class is marked as final so that nobody can overide the behavior of its method.
<br>
**Important Point from String :**
<br>
There are two ways to create String .
<br>
1.By creating String object. ex: String a = new String("hello"); 
Note : when we create String by creating object then In such a case, JVM will create a new string object in normal (non-pool) heap memory.But it will not placed in String constant pool. To add it to String constant pool you have to "intern" it.
```bash
String demo = new String("Hello");
demo.intern();
```

<br>
2.By String Literals. ex: String b = "hello";
<br>
Note : when we create String by Literals then first JVM will find the literals in String constant pool.if a string literal is not found in the string pool, the JVM will create a new string object in the heap and add a reference to this object in the string pool.If the string literal already exists in the string pool, the JVM will not create a new object but instead will reference the existing string.

<br> <br>
Java uses concept of String constant pools to make Java more memory efficient. The string pool itself is part of the heap space but managed separately by the JVM to optimize memory usage and performance for string literals.

**Important Point from String:**
All the String method will create a new String because String is immutable.The original String remains unchanged.


# StringBuffer:
StringBuffer is a peer class of String, it is mutable in nature and it is thread safe class , we can use it when we have multi threaded environment and shared object of string buffer i.e, used by mutiple thread. As it is thread safe so there is extra overhead, so it is mainly used for multithreaded program.
<br><br>

Thread-Safe => Thread safety refers to the property of a piece of code or a program that ensures it functions correctly when multiple threads access it concurrently.


# StringBuilder:
StringBuilder in Java represents an alternative to String and StringBuffer Class, as it creates a mutable sequence of characters and it is not thread safe. It is used only within the thread , so there is no extra overhead , so it is mainly used for single threaded program.

# StringTokenizer:
StringTokenizer class in Java is used to break a string into tokens. A StringTokenizer object internally maintains a current position within the string to be tokenized. 

```bash
import java.util.StringTokenizer;

public class Main {

  public static void main(String[] args) {
    StringTokenizer s = new StringTokenizer("sdf*j%fg#erk&asddfgsd");
    // StringTokenizer s = new StringTokenizer(String str,delimeter);
    while (s.hasMoreTokens()) {
      System.out.println(s.nextToken("*,&,#,%"));        
      

// O/p=sdf
j
fg
erk
asddfgsd
    }
  }
}


```

# StringJoiner: 
StringJoiner is a class in java.util package which is used to construct a sequence of characters(strings) separated by a delimiter and optionally starting with a supplied prefix and ending with a supplied suffix.

```bash
import java.util.StringJoiner;

public class StringJoinerExample {
    public static void main(String[] args) {
        // Create a StringJoiner with a delimiter, prefix, and suffix
        StringJoiner joiner = new StringJoiner(", ", "[", "]");

        // Add elements to the StringJoiner
        joiner.add("apple");
        joiner.add("banana");
        joiner.add("cherry");

        // Convert to a single string
        String result = joiner.toString();
        System.out.println(result);  // Output: [apple, banana, cherry]
    }
}
```
Note : It will throw NullPointerException if prefix is given as parameter in StringJoiner.
<br>
docs link for String : https://docs.oracle.com/javase/8/docs/api/java/lang/String.html
<br>

# Wrapper class
A Wrapper class in Java is a class whose object wraps or contains primitive data types. When we create an object to a wrapper class, it contains a field and in this field, we can store primitive data types. 
<br> 
Since J2SE 5.0, autoboxing and unboxing feature convert primitives into objects and objects into primitives automatically.
<br>
AutoBoxing =>
<br>
```bash
int a =12;

Integer j = a; // automatic conversion of primitive datatypes into Object.

Integer j = Integer.valueOf(a); // we can convert explicitly 
```
<br>

Unboxing => 
```bash
Integer a = new Integer(3);

int i = a; // automatic conversion of Object into primitive data type.

int i = a.intValue(); //we can also convert  explicitaly 

```
**If we want to convert any number to string then we have method**

int a =10; // convert primitive datatype to string
<br>
String str = String.valueOf();

<br>
Integer a =10 ;   // to convert object into string 
<br>
String str = a.toString();

<br>

# Arrays 
Array is a collection of similar data elements stored at contiguous memory location.

<br>
Arrays are stored in a contiguous block of memory. This means that if the array has n elements, each element will be located right next to the other in memory. Arrays in Java are objects that are stored in the heap memory. This allows arrays to be dynamically allocated at runtime.
<br>


**Java Arrays member:**
All the members are inherited from class Object; the only method of Object that is not inherited is its clone method.
<br>
The public method clone() overrides the clone method in class Object and throws no checked exceptions.


#  clone() method:
Object cloning refers to the creation of an exact copy of an object. It creates a new instance of the class of the current object and initializes all its fields with exactly the contents of the corresponding fields of this object.
<br>
There are 3 methods for creating Object Cloning in Java that are mentioned below:
<br>
1.Using Assignment Operator to create a copy of the reference variable:
```bash
// Java program to demonstrate that assignment operator 
// only creates a new reference to same object 
import java.io.*; 

// A test class whose objects are cloned 
class Test { 
	int x, y; 
	Test() 
	{ 
		x = 10; 
		y = 20; 
	} 
} 

// Driver Class 
class Main { 
	public static void main(String[] args) 
	{ 
		Test ob1 = new Test(); 

		System.out.println(ob1.x + " " + ob1.y); 

		// Creating a new reference variable ob2 
		// pointing to same address as ob1 
		Test ob2 = ob1; 

		// Any change made in ob2 will 
		// be reflected in ob1 
		ob2.x = 100; 

		System.out.println(ob1.x + " " + ob1.y); 
		System.out.println(ob2.x + " " + ob2.y); 
//O/P : 
//10 20
//100 20
//100 20

	} 
}
```
2.a copy using the clone() method:
```bash
// A Java program to demonstrate 
// shallow copy using clone() 
import java.util.ArrayList; 

// An object reference of this class is 
// contained by Test2 
class Test { 
	int x, y; 
} 

// Contains a reference of Test and 
// implements clone with shallow copy. 
class Test2 implements Cloneable { 
	int a; 
	int b; 
	Test c = new Test(); 
	public Object clone() throws CloneNotSupportedException 
	{ 
		return super.clone(); 
	} 
} 

// Driver class 
public class Main { 
	public static void main(String args[]) 
		throws CloneNotSupportedException 
	{ 
		Test2 t1 = new Test2(); 
		t1.a = 10; 
		t1.b = 20; 
		t1.c.x = 30; 
		t1.c.y = 40; 

		Test2 t2 = (Test2)t1.clone(); 

		// Creating a copy of object t1 
		// and passing it to t2 
		t2.a = 100; 

		// Change in primitive type of t2 will 
		// not be reflected in t1 field 
		t2.c.x = 300; 

		// Change in object type field will be 
		// reflected in both t2 and t1(shallow copy) 
		System.out.println(t1.a + " " + t1.b + " " + t1.c.x 
						+ " " + t1.c.y); 
		System.out.println(t2.a + " " + t2.b + " " + t2.c.x 
						+ " " + t2.c.y); 

// O/P:
10 20 300 40
100 20 300 40
	} 
}
```

3.Usage of clone() method – Deep Copy:
```bash
// A Java program to demonstrate 
// deep copy using clone() 

// An object reference of this 
// class is contained by Test2 
class Test { 
	int x, y; 
} 

// Contains a reference of Test and 
// implements clone with deep copy. 
class Test2 implements Cloneable { 
	int a, b; 

	Test c = new Test(); 

	public Object clone() throws CloneNotSupportedException 
	{ 
		// Assign the shallow copy to 
		// new reference variable t 
		Test2 t = (Test2)super.clone(); 

		// Creating a deep copy for c 
		t.c = new Test(); 
		t.c.x = c.x; 
		t.c.y = c.y; 

		// Create a new object for the field c 
		// and assign it to shallow copy obtained, 
		// to make it a deep copy 
		return t; 
	} 
} 

public class Main { 
	public static void main(String args[]) 
		throws CloneNotSupportedException 
	{ 
		Test2 t1 = new Test2(); 
		t1.a = 10; 
		t1.b = 20; 
		t1.c.x = 30; 
		t1.c.y = 40; 

		Test2 t3 = (Test2)t1.clone(); 
		t3.a = 100; 

		// Change in primitive type of t2 will 
		// not be reflected in t1 field 
		t3.c.x = 300; 

		// Change in object type field of t2 will 
		// not be reflected in t1(deep copy) 
		System.out.println(t1.a + " " + t1.b + " " + t1.c.x 
						+ " " + t1.c.y);       //10 20 30 40
		System.out.println(t3.a + " " + t3.b + " " + t3.c.x     
						+ " " + t3.c.y);       //100 20 300 40

	} 
}
```
<br> <br>
**Ararys class and its method:**
The Arrays class in java.util package is a part of the Java Collection Framework. This class provides static methods to dynamically create and access Java arrays. It consists of only static methods and the methods of Object class. The methods of this class can be used by the class name itself.


<br>
# Important point from Arrays method:
Difference between sort() an parallelSort() method:
sort() method is single thread method that uses Dual Pivot Quicksort algorithm to sort the data.
<br>
parallelSort() method is multi-threaded method. It can sort large arrays faster by dividing the array into segments, sorting them in parallel using multiple threads, and then merging the sorted segments.

# Jagged Arrays:
There may be a certain scenario where you want every row to have a different number of columns. This type of array is called a Jagged Array.
```bash
import java.io.*; 

class GFG { 
	public static void main(String[] args) 
	{ 
		// declaring a 2D array with 2 rows 
		int jagged[][] = new int[2][]; 

		// not specifying the 2nd dimension, 
		// and making it as jagged array 
		// first row has 2 columns 
		jagged[0] = new int[2]; 
		// second row has 4 columns 
		jagged[1] = new int[4]; 
		// Initializing the array 
		int count = 0; 
		for (int i = 0; i < jagged.length; i++) { 
			// remember to use jagged[i].length instead of 
			// jagged[0].length, since every row has 
			// different number of columns 
			for (int j = 0; j < jagged[i].length; j++) { 
				jagged[i][j] = count++; 
			} 
		} 

		// printing the values of 2D Jagged array 
		System.out.println("The values of 2D jagged array"); 
		for (int i = 0; i < jagged.length; i++) { 
			for (int j = 0; j < jagged[i].length; j++) 
				System.out.printf(jagged[i][j] + " "); 
			System.out.println(); 

//O/P:
//0 1 
//2 3 4 5 

		} 
	} 
}
```


**Final Ararys :**
Note that with final we are bound not to refer to another object but within the object data can be changed which means we can change the state of the object but not reference.
```bash
// Java Program to Illustrate Final Arrays

// Importing required classes
import java.util.*;

// Main class
class GFG {

	// Main driver method
	public static void main(String args[])
	{

		// Declaring a final array
		final int arr[] = { 1, 2, 3, 4, 5 };

		// Iterating over integer array
		for (int i = 0; i < arr.length; i++) {
			arr[i] = arr[i] * 10;
			System.out.println(arr[i]);
//O/P:
//10
//20
//30
//40
//50
		}
	}
}
```


# Reflect Array class in java:
The Array class in java.lang.reflect package is a part of the Java Reflection. This class provides static methods to create and access Java arrays dynamically. It is a final class, which means it can’t be instantiated or changed. Only the methods of this class can be used by the class name itself.
whereas the java.util.Arrays class contains various methods for manipulating arrays (such as sorting and searching).
```bash
// Java code to retrieve an element from an integer array,
// using the Array class:

import java.lang.reflect.Array;
import java.util.Arrays;

public class GfG {
	public static void main(String[] args)
	{

		// Get the size of the array
		int sizeOfArray = 3;

		// Create an integer array
		// using reflect.Array class
		// This is done using the newInstance() method
		int[] intArray = (int[])Array.newInstance(
			int.class, sizeOfArray);

		// Add elements to the array
		// This is done using the setInt() method
		Array.setInt(intArray, 0, 10);
		Array.setInt(intArray, 1, 20);
		Array.setInt(intArray, 2, 30);

		// Printing the Array content
		System.out.println(Arrays.toString(intArray));

		// Retrieve elements from the array
		// This is done using the getInt() method
		System.out.println("Element at index 0: "
						+ Array.getInt(intArray, 0));
		System.out.println("Element at index 1: "
						+ Array.getInt(intArray, 1));
		System.out.println("Element at index 2: "
						+ Array.getInt(intArray, 2));
	}
}
```

Note : we can also use reflect.Array class method in normal arrays.

 
**How to get max value from an array**

**int max = Arrays.stream(arr).max().getAsInt();**
<br>
<br>
**Arrays.stream(arr):**

Converts the array arr into an IntStream, which is a sequence of primitive int values.
<br>
**.max():**
Finds the maximum value in the stream. It returns an OptionalInt because the stream might be empty, in which case there wouldn't be a maximum value.
<br>
**.getAsInt():**

Retrieves the value from the OptionalInt. Since we're assuming the array is not empty, this operation is safe. However, if there's a possibility that the array could be empty, it's better to handle the empty case explicitly to avoid NoSuchElementException.

# Throwable class :
The Throwable class is the superclass of every error and exception in the Java language. Only objects that are one of the subclasses this class are thrown by any “Java Virtual Machine” or may be thrown by the Java throw statement.

# OOPS
**When to use Abstract class ?**
<br>
Sometimes we want to create a superclass that only defines a generalization form that will be shared by all of its subclasses, leaving it to each subclass to fill in the details.

<br>
# Why abstract class is faster than interface?
<br>
An abstract class is faster than an interface because the interface involves a search before calling any overridden method in Java whereas abstract class can be directly used. 

<br>
# How to use Inner Abstract class :
<br>
We can use the abstract keyword for declaring top-level classes (Outer class) as well as inner classes as abstract.
<br>

```bash
import java.io.*;

abstract class B {
	// declaring inner class as abstract with abstract
	// method
	abstract class C {
		abstract void myAbstractMethod();
	}
}
class D extends B {
	class E extends C {
		// implementing the abstract method
		void myAbstractMethod()
		{
			System.out.println(
				"Inside abstract method implementation");
		}
	}
}

public class Main {

	public static void main(String args[])
	{
		// Instantiating the outer class
		D outer = new D();

		// Instantiating the inner class
		D.E inner = outer.new E();
		inner.myAbstractMethod();  // Inside abstract method implementation
	}
}
```


# Important Point from Encapsulation :

Encapsulation can be achieved by declaring all the variables in a class as private and writing public methods in the class to set and get the values of the variables.

# Important Points about method overriding and static methods:

For class (or static) methods, the method according to the type of reference is called, not according to the object being referred, which means method call is decided at compile time.
<br>
For instance (or non-static) methods, the method is called according to the type of object being referred, not according to the type of reference, which means method calls is decided at run time.
<br>
An instance method cannot override a static method, and a static method cannot hide an instance method. 
<br>
In a subclass (or Derived Class), we can overload the methods inherited from the superclass. Such overloaded methods neither hide nor override the superclass methods — they are new methods, unique to the subclass.

# Class as return type of method (example of Polymorphism) :
```bash
import java.util.Random;

class DeliveryBoy {

    public void deliver() {
        System.out.println("Delivering Item");
    }

    public static void main(String[] args) {
        DeliveryBoy deliveryBoy = getDeliveryBoy();
        deliveryBoy.deliver();
    }

    private static DeliveryBoy getDeliveryBoy() {
        Random random = new Random();
        int number = random.nextInt(5);
        return number % 2 == 0 ? new Postman() : new FoodDeliveryBoy();
    }
}

class Postman extends DeliveryBoy {
    @Override
    public void deliver() {
        System.out.println("Delivering Letters");
    }
}

class FoodDeliveryBoy extends DeliveryBoy {
    @Override
    public void deliver() {
        System.out.println("Delivering Food");
    }
}
```




# How many Types of interfaces in Java?
<br>
Types of interfaces in Java are mentioned below:
<br>
1.Functional Interface : 
<br>
A functional interface is an interface that contains only one abstract method.
<br>
2.Marker interface:
<br>
Tagged or marker Interfaces are interfaces without any methods they serve as a marker without any capabilities.
<br>


# Use of Private method in java:
```bash
interface Practice {
	public abstract void show();
	public default void display() {
	  System.out.println("default method");
	  show1();
	}
  
	private void show1() // it may be static or non static
	{
	  System.out.println("Private method");
	}
  }
  
  class test implements Practice {
	public void show() {
	  System.out.println("This is implemented abstract method");
	}
  
	public void display() {
	  System.out.println("this is overided default method1 ");
	}
  
	public static void main(String args[]) {
	  Practice a = new test();
	  a.show();   // This is implemented abstract method
	
	  a.display();  // this is overided default method1 
	}
  }
```
<br>

# we can intialize the object's variables in the method also.
```bash
// Java Program to demonstrate 
// Java Inheritance

// Parent Class
class Person1 {
	// Variables
	int id;
	String name;

	// Java Methods
	void set_Person(int id, String name)
	{
		try {
			this.id = id;
			this.name = name;
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	void disp_Person()
	{
		System.out.print(id + "\t" + name + "\t");
	}
}

// Child Class
class Employee1 extends Person1 {
	int sal;
	String desgn;
	void set_Emp(int id, String name, String desgn, int sal)
	{
		try {
			set_Person(id, name);
			this.desgn = desgn;
			this.sal = sal;
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	void disp_Emp()
	{
		disp_Person();
		System.out.print(desgn + "\t" + sal);
	}

	// Main function
	public static void main(String args[])
	{

		Employee1 e1 = new Employee1();
		e1.set_Emp(1001, "Manjeet", "AP", 20000);
		e1.disp_Emp();   // 1001  Manjeet  AP  20000
	}
}
```

# Important Point from Interface :
```bash
interface Practice {
	public abstract void show();
	
  }
interface GFG {

   void show();
}
public class Test implements Practice , GFG {
	public void show() {
	  System.out.println("This is implemented abstract method");
	}
    
  
	public static void main(String args[]) {
	  Test  a = new Test();
	  a.show();


//OP : This is implemented abstract method
	}
  }
```
<br>
Note : Since both Practice and GFG declare a method with the same signature (void show()), the show() method in the Test class provides a single implementation that satisfies the requirements of both interfaces. Therefore, the show() method in Test overrides the show() method declared in both Practice and GFG.

# How diamond Problem is solved in java(Example of Hybrid Inheritance) :

```bash
// Java program to demonstrate How Diamond Problem
// Is Handled in case of Default Methods

// Interface 1
interface GPI {

	// Default method
	default void show()
	{

		// Print statement
		System.out.println("Default GPI");
	}
}

// Interface 2
// Extending the above interface
interface PI1 extends GPI {
}

// Interface 3
// Extending the above interface
interface PI2 extends GPI {
}

// Main class
// Implementation class code
class TestClass implements PI1, PI2 {

	// Main driver method
	public static void main(String args[])
	{

		// Creating object of this class
		// in main() method
		TestClass d = new TestClass();

		// Now calling the function defined in interface 1
		// from whom Interface 2and 3 are deriving
		d.show();

// O/P : Default GPI
	}
}
```
# Nested Interface :
We can declare interfaces as members of a class or another interface. Such an interface is called a member interface or nested interface. Interface in a class Interfaces (or classes) can have only public and default access specifiers when declared outside any other class.This interface declared in a class can either be default, public, protected not private.
<br>
Example :
<br>
```bash
class Test {
	interface Yes {
		void show();
	}
}

class Testing implements Test.Yes {
	public void show()
	{
		System.out.println("show method of interface");
	}
}

class A {
	public static void main(String[] args)
	{
		Test.Yes obj;
		Testing t = new Testing();
                t.show();   // show method of interface
		obj = t;
		obj.show();  // show method of interface
                
	}
}
```
<br>

# Method Overloading :
when two or more methods with same name but different parameters are defined in a class then it is called method overloading.

# Important Point from method overloading :
```bash
public class Test
{
	// Overloaded methods
	public void fun(Integer i)
	{
		System.out.println("fun(Integer ) ");
	}
	public void fun(String name)
	{
		System.out.println("fun(String ) ");
	}

	// Driver code 
	public static void main(String [] args)
	{
		Test mv = new Test();

		// This line causes error
		mv.fun(null);
	}
}
```


**Note :** method arguments Integer and String both are not primitive data types in Java. That means they accept null values. When we pass a null value to the method1 the compiler gets confused which method it has to select, as both are accepting the null. 

<br>

**Another Point from method overloading :**
<img width="393" alt="image" src="https://github.com/user-attachments/assets/0f441667-317b-489a-aa64-4dea9711fc6d">

<br>
``` bash
// Demo Class 
class Demo { 
	public void show(int x) 
	{ 
		System.out.println("In int" + x); 
	} 
	public void show(String s) 
	{ 
		System.out.println("In String" + s); 
	} 
	public void show(byte b) 
	{ 
		System.out.println("In byte" + b); 
	} 
} 

class UseDemo { 
	public static void main(String[] args) 
	{ 
		byte a = 25; 
		Demo obj = new Demo(); 

		// it will go to 
		// byte argument 
		obj.show(a); 

		// String 
		obj.show("hello"); 

		// Int 
		obj.show(250); 

		// Since char is 
		// not available, so the datatype 
		// higher than char in terms of 
		// range is int. 
		obj.show('A'); 

		// String 
		obj.show("A"); 

		// since float datatype 
		// is not available and so it's higher 
		// datatype, so at this step their 
		// will be an error. 
		obj.show(7.5); 
	} 
}
```
<br>
<br>

**Example of overloading using overriding :**
```bash
class App {

	void display(int a , int b ) {
		int sum = a + b;
        System.out.println(sum);	}
}

public class Test extends App {
	void display(int a , int b , int c ) {
		int sum = a + b + c ;
		System.out.println(sum);
	}

	public static void main(String args[] ) {
		Test a  = new Test();
		a.display(2,8 ); //10
		a.display(2,3,4);// 9
	}
}
```
# Method Overriding :
when subclass defines methods that are already defined in super class then this process is called  method overriding.

# Important Point from Method Overriding: 
1.The access modifier for an overriding method can allow more, but not less, access than the overridden method. For example, a protected instance method in the superclass can be made public, but not private, in the subclass. 
<br>
2. when a static method of Super class is also defined in sub class as static  then it hides the statement written in subclass.
<br>
```bash
// Java program to show that
// if the static method is redefined by
// a derived class, then it is not
// overriding, it is hiding

class Parent {
	// Static method in base class
	// which will be hidden in subclass
	static void m1()
	{
		System.out.println("From parent "
						+ "static m1()");
	}

	// Non-static method which will
	// be overridden in derived class
	void m2()
	{
		System.out.println(
			"From parent "
			+ "non - static(instance) m2() ");
	}
}

class Child extends Parent {
	// This method hides m1() in Parent
	static void m1()
	{
		System.out.println("From child static m1()");
	}

	// This method overrides m2() in Parent
	@Override public void m2()
	{
		System.out.println(
			"From child "
			+ "non - static(instance) m2() ");
	}
}

// Driver class
class Main {
	public static void main(String[] args)
	{
		Parent obj1 = new Child();

		// As per overriding rules this
		// should call to class Child static
		// overridden method. Since static
		// method can not be overridden, it
		// calls Parent's m1()
		obj1.m1();

		// Here overriding works
		// and Child's m2() is called
		obj1.m2();
	}
}
```

3.The overriding method must have the same return type (or subtype) :
<br>
From Java 5.0 onwards it is possible to have different return types for an overriding method in the child class, but the child’s return type should be a sub-type of the parent’s return type. This phenomenon is known as the covariant return type.
<br>
```bash
class Base {
	Base fun() {
	   System.out.println("Base fun");    
	   return new Base() ;
	}
  }
	
  class Derived extends Base {
	Derived fun() {
	   System.out.println("Derived fun"); 
	   return new Derived();    
	}
	public static void main(String[] args) {
		Base obj = new Derived();
		obj.fun();    // Derived fun
	}  
  }
```

<br>
4.If the super-class overridden method does not throw an exception, the subclass overriding method can only throw the unchecked exception, throwing a checked exception will lead to a compile-time error.
```bash
// Java program to demonstrate overriding when
// superclass method does not declare an exception

class Parent {
	void m1() { System.out.println("From parent m1()"); }

	void m2() { System.out.println("From parent m2()"); }
}

class Child extends Parent {
	@Override
	// no issue while throwing unchecked exception
	void m1() throws ArithmeticException
	{
		System.out.println("From child m1()");
	}

	@Override
	// compile-time error
	// issue while throwing checked exception
	void m2() throws Exception
	{
		System.out.println("From child m2");
	}
}
```
<br> <br>

5. If the superclass overridden method does throw an exception, the subclass overriding method can only throw the same, subclass exception. Throwing parent exceptions in the Exception hierarchy will lead to compile time error. Also, there is no issue if the subclass overridden method is not throwing any exception. 
 
```bash
// Java program to demonstrate overriding when
// superclass method does declare an exception

class Parent {
	void m1() throws RuntimeException
	{
		System.out.println("From parent m1()");
	}
}

class Child1 extends Parent {
	@Override
	// no issue while throwing same exception
	void m1() throws RuntimeException
	{
		System.out.println("From child1 m1()");
	}
}
class Child2 extends Parent {
	@Override
	// no issue while throwing subclass exception
	void m1() throws ArithmeticException
	{
		System.out.println("From child2 m1()");
	}
}
class Child3 extends Parent {
	@Override
	// no issue while not throwing any exception
	void m1()
	{
		System.out.println("From child3 m1()");
	}
}
class Child4 extends Parent {
	@Override
	// compile-time error
	// issue while throwing parent exception
	void m1() throws Exception
	{
		System.out.println("From child4 m1()");
	}
}
```

# When to use Method Oveerriding :
Example:
<br>
```bash
// Java program to demonstrate application
// of overriding in Java

// Base Class
class Employee {
	public static int base = 10000;
	int salary() { return base; }
}

// Inherited class
class Manager extends Employee {
	// This method overrides salary() of Parent
	int salary() { return base + 20000; }
}

// Inherited class
class Clerk extends Employee {
	// This method overrides salary() of Parent
	int salary() { return base + 10000; }
}

// Driver class
class Main {
	// This method can be used to print the salary of
	// any type of employee using base class reference
	static void printSalary(Employee e)
	{
		System.out.println(e.salary());
	}

	public static void main(String[] args)
	{
		Employee obj1 = new Manager();

		// We could also get type of employee using
		// one more overridden method.loke getType()
		System.out.print("Manager's salary : ");
		printSalary(obj1);

		Employee obj2 = new Clerk();
		System.out.print("Clerk's salary : ");
		printSalary(obj2);
	}
}
```
# concepts of stack memory and heap memory
In Java, memory management is a critical aspect of the language's runtime environment.
 Both stack and heap are areas of memory where data can be stored during program execution, but they serve different purposes and have different characteristics.
<br>

**1. Stack Memory:**
<br>
**Purpose:**
Stack memory is used for storing method execution frames and local variables and references.
<br>
**Characteristics:**
Each thread in a Java application has its own stack.
Memory allocation and deallocation on the stack follow a last-in, first-out (LIFO) principle.
It has a fixed size determined at the startup of the Java Virtual Machine (JVM).
Access to stack memory is faster than heap memory because of its simple allocation and deallocation mechanism.
<br>
**Usage:**

Method calls and local variables are stored in stack memory.
Variables created within a method, including primitive types and references to objects, are stored in stack memory.
Stack memory is automatically managed by the JVM, and it's not directly accessible to Java programmers.


**2. Heap Memory:**
<br>
**Purpose:**
Heap memory is used for dynamic memory allocation. It's where objects, arrays, and instance variables are allocated.
<br>
**Characteristics:**
All Java objects reside in the heap.
Memory allocation and deallocation on the heap are less predictable than on the stack and follow a more complex process.
The size of the heap can dynamically increase or decrease during the execution of a Java program.
Memory management in the heap is handled by the garbage collector, which identifies and removes objects that are no longer in use to free up memory.
<br>
**Usage:**
Objects created using the new keyword are allocated in heap memory.
Instance variables of objects are stored in heap memory.
The heap is shared among all threads in a Java application.

<br>
<br>

**Comparison:**
<br>
<br>
**Lifetime:**
Stack memory is short-lived and exists only during the execution of a method, while heap memory persists for the duration of the program's execution or until the object is no longer referenced.
<br>
**Access:**
Access to stack memory is faster than access to heap memory due to its simple allocation and deallocation mechanism.
<br>
**Size:**
Stack memory size is fixed and usually smaller than the heap. It's determined at JVM startup.
The heap can dynamically increase or decrease in size during program execution based on the memory requirements of the application and the available system resources.

# Metaspace :
Metaspace is a part of JVM memory Structure and is used to store class metadata, such as class definitions, method information, and other class-related data.

# Method Area:
It is a logical part of the heap area and is created on virtual machine startup.
This memory is allocated for class structures, method data and constructor field data, and also for interfaces or special method used in class. Heap can be of fixed or dynamic size depending upon the system’s configuration.
Can be of a fixed size or expanded as required by the computation. Needs not to be contiguous.
<br>
Note: Though method area is logically a part of heap, it may or may not be garbage collected even if garbage collection is compulsory in heap area.
<br>
Actually It is a part of Metaspace.

# Native method Stacks:
Also called as C stacks, native method stacks are not written in Java language. This memory is allocated for each thread when its created. And it can be of fixed or dynamic nature.

# Program counter (PC) registers:
Each JVM thread which carries out the task of a specific method has a program counter register associated with it. The non native method has a PC which stores the address of the available JVM instruction whereas in a native method, the value of program counter is undefined. PC register is capable of storing the return address or a native pointer on some specific platform.

# Advantages of Packages 

**1.Java Package is Used to Categorize the Classes and Interfaces for Easier Maintenance:**
In Java, packages serve as a way to group related classes, interfaces, enumerations, and annotations.
By organizing code into packages, developers can manage and maintain large codebases more efficiently.
<br>
**2.Java Package Removes Naming Collision:**
Naming collisions occur when two classes or interfaces have the same name.
Packages help in avoiding these conflicts by providing a namespace for each class or interface. 

**3.Java Package Provides Access Protection:**
Java packages also play a crucial role in defining the accessibility of classes and their members. This is achieved through access modifiers and package-level access control. 

# Package 
Package is a group of related classes,interfaces and subpackages.
<br>
Important Point : Packages can be considered as data encapsulation (or data-hiding).
<br>
# Subpackages:
Packages that are inside another package are the subpackages. These are not imported by default, they have to imported explicitly. Also, members of a subpackage have no access privileges, i.e., they are considered as different package for protected and default access specifiers.

# Static Import of a Package : 
Static import is a feature introduced in Java programming language ( versions 5 and above ) that allows members ( fields and methods ) defined in a class as public static to be used in Java code without specifying the class in which the field is defined.
```bash
// Note static keyword after import.
import static java.lang.System.*;

class StaticImportDemo {
    public static void main(String args[])
    {
        // We don't need to use 'System.out'
        // as imported using static.
        out.println("GeeksforGeeks");
    }
}
```

# Java System Packages:

Java system packages are a set of pre-defined packages provided by the Java Standard Library (also known as the Java API). These packages include classes and interfaces that are fundamental to the design and functioning of Java applications. They offer essential functionality, such as basic input and output operations, string manipulation, data structures, networking, graphical user interface (GUI) development, and more.
<br>
Here are some of the core Java system packages and their primary purposes:
<br> <br>
**1.java.lang**
<br>
This package is automatically imported into every Java program and contains fundamental classes and interfaces.
<br>
**Classes:** Object, Class, String,(wrapper classes) Integer,Double,Long,Short , Float,Byte,Boolean, Math, System, Thread, Exception, etc.
<br>
**Purpose:** Provides classes that are fundamental to the design of the Java programming language.
<br>
<br>

**2. java.util**
<br>
This package contains the collections framework, legacy collection classes, event model, date and time facilities, and miscellaneous utility classes.
<br>
**Classes:** ArrayList,Arrays,LinkedList,Stack, HashMap, HashSet, Date, Calendar, Random, Scanner, etc.
<br>
**Purpose:** Provides utility classes and data structures like lists, maps, sets, and utilities for date and time manipulation.
<br>
<br>

**3.java.io**
<br>

This package provides for system input and output through data streams, serialization, and the file system.
<br>
**Classes:** File, FileInputStream, FileOutputStream, BufferedReader, BufferedWriter, PrintStream, etc.
<br>
**Purpose:** Handles input and output operations, including file I/O and stream-based I/O.
<br>
<br>

**4.java.ino**
<br>

This package provides classes for the new I/O (non-blocking I/O) facilities.
<br>

**Classes:** ByteBuffer, CharBuffer, FileChannel, Paths, Path, Files, etc.
<br>

**Purpose:** Offers advanced I/O capabilities, including buffer management, file channels, and file operations.
<br>
<br>

**5. java.net**
<br>
This package provides classes for implementing networking applications.
<br>

**Classes:** URL, URLConnection, Socket, ServerSocket, InetAddress, HttpURLConnection, etc.<br>
<br>


**Purpose:** Facilitates network operations, such as URL handling, socket programming, and networking utilities.
<br>
<br>

**6. java.awt**
<br>

This package contains classes for creating user interfaces and for painting graphics and images.
<br>

**Classes:** Button, Label, Canvas, Frame, Graphics, Color, Font, etc.
<br>

**Purpose:** Provides the Abstract Window Toolkit (AWT) for creating GUI components and handling events.
<br>
<br>


**7.javax.swing**
This package provides a set of "lightweight" (all-Java language) components that work the same on all platforms.
<br>

**Classes:** JButton, JLabel, JPanel, JFrame, JTextField, etc.
<br>

**Purpose:** Offers a rich set of GUI components that enhance and extend the AWT framework.
<br>
<br>

**8. java.sql**
<br>

This package provides the API for accessing and processing data stored in a data source (usually a relational database) using the Java programming language.
<br>

**Classes:** Connection, Statement, PreparedStatement, ResultSet, SQLException, etc.
<br>

**Purpose:** Enables database connectivity and operations using JDBC (Java Database Connectivity).
<br>

**9. java.security**
<br>

This package provides the classes and interfaces for the security framework.
<br>

**Classes:** MessageDigest, KeyPair, Signature, SecureRandom, AccessController, etc.
<br>

**Purpose:** Supports the development of security features, including cryptography, authentication, and access control.
<br>

**10. java.time**
<br>

This package provides the API for date and time operations.
<br>

**Classes:** LocalDate, LocalTime, LocalDateTime, ZonedDateTime, Duration, Period, etc.
<br>

**Purpose :**  Offers a comprehensive set of classes for date and time manipulation, introduced in Java 8 to replace the older java.util.Date and java.util.Calendar.


# Thread : 

**There are two ways to create thread :**
1. Extending the Thread class
<br>
```bash
class MultithreadingDemo extends Thread {
	public void run() {
		try {
			// Displaying the thread that is running
			for (int i = 0; i < 100; i++) {
				System.out.println("hi");
			}
		} catch (Exception e) {

		}
	}
}

class ThreadTest2 extends Thread {
	public void run() {
		try {
			for (int i = 0; i < 100; i++) {
				System.out.println("hello");
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}
}

// Main Class
public class Test {
	public static void main(String[] args) {
		MultithreadingDemo a = new MultithreadingDemo();
		ThreadTest2 b = new ThreadTest2();
		a.start();
		b.start();
	}

}

```
<br>

2. Implementing the Runnable Interface
```bash
class ThreadTest3 implements Runnable {

	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println("hello java World");
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {

				e.printStackTrace();
			}
		}
	}

}

class ThreadTest4 implements Runnable {

	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println("java World");
		}
	}

}

public class Test {

	public static void main(String[] args) {
		ThreadTest3 a = new ThreadTest3();
		ThreadTest4 b = new ThreadTest4();

		Runnable c = new Thread(a);
        Thread.currentThread().getPriority();
		Runnable d = new Thread(b);
		c.run();

		d.run();
	}
}
```


# Exception Handling 
It is the mechanism to handle the run time exception so that normal flow of program can be maintained.

<br>
<br>
# Exception : Exceptions are unexpected events that disrupts the normal flow of program.

<br>
<br>

# Errors : Errors are serious problem that can not be handled by using try-catch statement.
<br>
<br>

# Types of Built-in Exception In Java:
<br>

**1.Checked Exception :** These are the exception that which are checked at compile time.
<br>

**2.Unchecked Exception :** These are the exception that which are checked at run time.
 
<br>

**# User Defined Exception :**
Sometimes, the built-in exceptions in Java are not able to describe a certain situation. In such cases, the user can also create exceptions which are called ‘user-defined Exceptions’. 

# How does JVM handle Exception :

There might be a list of the methods that had been called to get to the method where an exception occurred. This ordered list of methods is called Call Stack.
<br>
The run-time system starts searching from the method in which the exception occurred and proceeds through the call stack in the reverse order in which methods were called.
<br>
If it finds an appropriate handler, then it passes the occurred exception to it. An appropriate handler means the type of exception object thrown matches the type of exception object it can handle.
<br>
If the run-time system searches all the methods on the call stack and couldn’t have found the appropriate handler, then the run-time system handover the Exception Object to the default exception handler, which is part of the run-time system. This handler prints the exception information in the following format and terminates the program abnormally.
<br>

# try , catch ,throw , throws ,finally

**try :** try block is used to enclosed a piece of code which can throw exception.
<br>
**catch:** The catch block is used to handle the uncertain condition of a try block. A try block is always followed by a catch block, which handles the exception that occurs in the associated try block.
<br>

**throw :** The throw keyword is used to transfer control from the try block to the catch block. 
<br>
**throws :** The throws keyword is used for exception handling without try & catch block. It specifies the exceptions that a method can throw to the caller and does not handle itself. 
<br>
**Note :** throws keyword is required only for checked exceptions.
<br>

**finally :** Finally block is used to execute necessary part of our program. This block is always executed whether the exception occurred or not.


# Chained Exception :
Chained Exceptions allows to relate one exception with another exception, i.e one exception describes cause of another exception. For example, consider a situation in which a method throws an ArithmeticException because of an attempt to divide by zero but the actual cause of exception was an I/O error which caused the divisor to be zero. The method will throw only ArithmeticException to the caller. So the caller would not come to know about the actual cause of exception. Chained Exception is used in such type of situations.
```bash
// Java program to demonstrate working of chained exceptions 
public class ExceptionHandling 
{ 
	public static void main(String[] args) 
	{ 
		try
		{ 
			// Creating an exception 
			NumberFormatException ex = 
					new NumberFormatException("Exception"); 

			// Setting a cause of the exception 
			ex.initCause(new NullPointerException( 
					"This is actual cause of the exception")); 

			// Throwing an exception with cause. 
			throw ex; 
		} 

		catch(NumberFormatException ex) 
		{ 
			// displaying the exception 
			System.out.println(ex); 

			// Getting the actual cause of the exception 
			System.out.println(ex.getCause()); 
		} 
	} 
} 
```


# Important point from NullPointerExceptions :
if(string/objects).equals(null){} // this is valid. 
<br>
if(null.equals(string/object){}    // this throws NullPointerExceptions
<br>
<br>
**Note :** NullPointerException occurs when one tries to access or manipulate object reference that has a Null value stored in it.



# How to avoid  NullPointerExceptions;
There are certain methods to handle Null Pointer Exception in Java are mentioned below:
<br>
1.String comparison with literals
<br>
2.Keeping a Check on the arguments of a method
<br>
3.Use of Ternary Operator
<br>



# Virtual Memory Error:

Virtual memory error refers to problems related to the management and allocation of virtual memory by the operating system (OS). Virtual memory is a memory management technique that allows an operating system to compensate for physical memory shortages, temporarily transferring data from random access memory (RAM) to disk storage.

Insufficient Virtual Memory: When the combined total of RAM and allocated virtual memory (page file) is insufficient to handle the current demands of running applications, the OS may produce a virtual memory error.

# OutOfMemoryError :
It occurs due to memory leak.
<br>
**Memory Leaks :**There might be situations where an application creates lots of objects and does not use them. Just because every objects has valid references, garbage collector in Java can’t destroys the objects. Such types of useless objects are called as Memory leaks.
<br>
<br>
OutOfMemoryError in Java is a runtime error thrown by the Java Virtual Machine (JVM) when it cannot allocate an object because it is out of heap memory. This error indicates that the garbage collector has failed to free up enough memory for a new object. 


# Difference between Exception and Error:

Recoverability:

Exception: Usually represents conditions that can be recovered from. The application can catch and handle these exceptions to continue running.
Error: Represents serious issues that are generally not recoverable. The application is usually unable to handle these errors and may need to terminate.
Handling:

Exception: Can be caught using a try-catch block. Checked exceptions must be either caught or declared in the method signature.
Error: Generally should not be caught. Handling errors is often not practical as they signify serious problems that the application cannot reasonably be expected to recover from.

Examples:

Exception: IOException, SQLException, NullPointerException.
Error: OutOfMemoryError, StackOverflowError, VirtualMachineError.



# Use of finalize() method;
The primary purpose of the finalize method is to perform cleanup operations on resources that are not managed by the Java garbage collector. This includes resources like file handles, network connections, or database connections.

example =>
``` bash
public class ResourceHolder {
    private FileOutputStream fileOutputStream;

    public ResourceHolder(String fileName) throws FileNotFoundException {
        fileOutputStream = new FileOutputStream(fileName);
    }

    @Override
    protected void finalize() throws Throwable {
        try {
            if (fileOutputStream != null) {
                fileOutputStream.close();
                System.out.println("FileOutputStream closed.");
            }
        } finally {
            super.finalize();
        }
    }
}
```
<br>

Note =>  In this example, the finalize method ensures that the FileOutputStream is closed before the object is garbage collected.

# Byte Stream
Byte streams are used for handling I/O of raw binary data. They read and write data in bytes (8-bit). Byte streams are suitable for handling binary data such as images, audio files, and other types of binary content.

Key Classes for Byte Stream

InputStream:

This is an abstract class that represents an input stream of bytes.
Common subclasses include FileInputStream, ByteArrayInputStream, BufferedInputStream, and DataInputStream.


OutputStream:

This is an abstract class that represents an output stream of bytes.
Common subclasses include FileOutputStream, ByteArrayOutputStream, BufferedOutputStream, and DataOutputStream.


Example =>
``` bash
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("input.txt");
             FileOutputStream fos = new FileOutputStream("output.txt")) {
             
            int byteData;
            while ((byteData = fis.read()) != -1) {
                fos.write(byteData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```
# Character Stream

Character streams are used for handling I/O of character data. They read and write data in characters (16-bit Unicode). Character streams are suitable for handling text data.

Key Classes for Character Stream
Reader:

This is an abstract class that represents an input stream of characters.
Common subclasses include FileReader, BufferedReader, CharArrayReader, StringReader, and InputStreamReader.
Writer:

This is an abstract class that represents an output stream of characters.
Common subclasses include FileWriter, BufferedWriter, CharArrayWriter, StringWriter, and OutputStreamWriter.


Example => 
``` bash
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharacterStreamExample {
    public static void main(String[] args) {
        try (FileReader fr = new FileReader("input.txt");
             FileWriter fw = new FileWriter("output.txt")) {
             
            int charData;
            while ((charData = fr.read()) != -1) {
                fw.write(charData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

# Efficiency of Byte Stream and Character Stream ;
Byte Stream
Efficiency with Binary Data: Byte streams are typically more efficient when dealing with binary data (like images, audio files, and other non-text files). This is because they read and write raw binary data directly in 8-bit bytes, which involves less overhead.
No Encoding/Decoding Overhead: Since byte streams do not involve character encoding and decoding, they avoid the overhead associated with converting between bytes and characters.

Character Stream
Efficiency with Text Data: Character streams are optimized for handling text data. They read and write 16-bit Unicode characters, which makes them suitable for text files and ensures proper handling of different character encodings.
Encoding/Decoding Overhead: Character streams involve encoding and decoding of characters to and from bytes, which can introduce some overhead. However, this overhead is necessary for correctly processing text data, especially when dealing with different character sets and encodings.


# MVC
**1. Model**
Definition: The model represents the data and the business logic of the application. It directly manages the data, logic, and rules of the application.
Responsibilities:
Retrieve data from the database.
Handle data processing and business logic.
Notify the view of any data changes, often through a notification mechanism like observers.
Example: In an e-commerce application, the model would be responsible for handling data related to products, users, and orders.
**2. View**
Definition: The view is the user interface of the application. It displays data from the model to the user and sends user commands to the controller.
Responsibilities:
Render data in a user-friendly format.
Receive user input and display results.
Refresh the display when data in the model changes.
Example: In the same e-commerce application, the view would be the HTML pages or user interface elements that display product listings, user information, and shopping carts.
**3. Controller**
Definition: The controller acts as an intermediary between the model and the view. It processes user inputs and interacts with the model to update the view accordingly.
Responsibilities:
Handle user input from the view.
Update the model based on user actions.
Select the view to display based on the model state and user input.
Example: In the e-commerce application, the controller would manage actions like adding items to a cart, processing user logins, and handling checkout processes






# Swing

**JButton :** The JButton class is used to create a labeled button that has platform independent implementation.
<br>

**Important point from JButton :**
```bash
// Event Listener : ActionListener 

// Registration method : button.addActionListener(ActionListener a)

// Override method :

public void actionPerformed(ActionEvent e){
if(e.getSource()== button){}
}

```

**How to change the font of text in label (same in textfield and textarea)**

 label.setFont(new Font("Serif", Font.BOLD, 50));
 <br>
 **Important Point From JTextField :**
 
```bash
// Event Listener : KeyListener
<br>
// Registration method1 : textbox1.addKeyListener(KeyListener a)

//Override method1:

public void keyPressed(KeyEvent e){
}

public void KeyTyped(KeyEvent e){
}

public void KeyReleased(KeyEvent e){
}

```
 
**Important Point from JPasswordField:**
<br>
password.getPassword() method returns array of char.


<br>

**JCheckBox :** The JCheckBox class is used to create a checkbox. It is used to turn an option on (true) or off (false). It is used to check multiple checkbox.
**Important Point from JCheckBox :**


```bash
// Event Listener : ItemListener,ActionListener
<br>
// Registration method1 : checkbox.addItemListener(ItemListener a)
// Registration method2 : checkbox.addActionListener(ActionListener a)

//Override method1:

public void itemStateChanged(ItemEvent e){
if(e.getStateChange() == 1){}
}


//Override method2:
public void actionPerformed(ActionEvent e){
if(checkbox.isSelected(){}
}
```

**JRadioButton:**
The JRadioButton class is used to create a radio button. It is used to choose one option from multiple options.
<br>
**Important Point from JRadioButton :**
``` bash
JRadioButton r1 = new JRadioButton("A");
JRadioButton r2 = new JRadioButton("B");
ButtonGroup bg = new JButtonGroup();
bg.add(r1);
bg.add(r2);
frame.add(r1);
frame.add(r2);
```
**For Message pop up:**
```bash
JOptionPane.showMessageDialog(this,"Student Data Updated");

JOptionPane.showMessageDialog(f,"Successfully Updated.","Alert",JOptionPane.WARNING_MESSAGE);  // **for alert**

 String name=JOptionPane.showInputDialog(f,"Enter Name");   // **for taking input**
 
 public void windowClosing(WindowEvent e) {  
    int a=JOptionPane.showConfirmDialog(f,"Are you sure?");   // **for select an option**
if(a==JOptionPane.YES_OPTION){  
    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
}  
}

```
<br>

<br>

**JComboBox :** The object of Choice class is used to show popup menu of choices. Choice selected by user is shown on the top of a menu.
<br>

**Important Point from JComboBox :**

```bash
// Event Listener : ItemListener,ActionListener
<br>
// Registration method1 : combobox.addItemListener(ItemListener a)
// Registration method2 : combobox.addActionListener(ActionListener a)  

//Override method1:

public void itemStateChanged(ItemEvent e){
if(e.getItem() == ""){}
}


//Override method2:
public void actionPerformed(ActionEvent e){
if(combobox.getSelectedIndex()==1){}
if(combobox.getSelectedItem()== "A"){}
}
```


**JTable :** The JTable class is used to display data in tabular form.It is composed of rows and columns.
<br>
```bash
 final JTable jt=new JTable(data,column);

// Some Basic properties of JTable

jt.setCellSelectionEnabled(true);  
ListSelectionModel select= jt.getSelectionModel();    // to select a value from table.
select.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

// Event Listener : ListSelectionListener
<br>
// Registration method1 : combobox.addListSelectionListener(ListSelectionListener a)  

//Override method1:

public void valueChanged(ListSelectionEvent e){
int [] row = jt.getSelectedRows();
int [] columns = jt.getSelectedColumns();
String Data = (String) jt.getValueAt(row[i], columns[j]);
}



// Other properties of JTable:

 ResultSet resultSet = statement.executeQuery("select * from Fee_Details;"); // IN jdbc
            ResultSetMetaData rsmd = resultSet.getMetaData();

            // Create default table model
            model = new DefaultTableModel() {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false; // All cells are non-editable
                }
            };

        
            int columns = rsmd.getColumnCount();
            final String[] colname = new String[columns];
            for (int i = 0; i < columns; i++) {
                colname[i] = rsmd.getColumnName(i + 1);
            }

            model.setColumnIdentifiers(colname);

            while (resultSet.next()) {
                final String[] row = new String[columns];
                for (int i = 0; i < columns; i++) {
                    row[i] = resultSet.getString(i + 1);
                }
                model.addRow(row);
            }

            tableData = new JTable(model);

            int[] columnWidths = { 200, 200, 200, 500, 200, 200, 200 };

            for (int i = 0; i < columns; i++) {
                TableColumn column = tableData.getColumnModel().getColumn(i);
                column.setPreferredWidth(columnWidths[i]);
            }

            tableData.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
            JScrollPane sp = new JScrollPane(tableData);
            sp.setBounds(30, 150, 1200, 500);

            sp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
            sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);


// FOR create a button to search data enter in textfield from table .
 @Override
    public void keyPressed(KeyEvent e) {
        TableRowSorter<DefaultTableModel> obj = new TableRowSorter<>(model);
        tableData.setRowSorter(obj);
        obj.setRowFilter(RowFilter.regexFilter(text1.getText()));
    }

    @Override
    public void keyTyped(KeyEvent e) {
        TableRowSorter<DefaultTableModel> obj = new TableRowSorter<>(model);
        tableData.setRowSorter(obj);
        obj.setRowFilter(RowFilter.regexFilter(text1.getText()));
    }

    @Override
    public void keyReleased(KeyEvent e) {
        TableRowSorter<DefaultTableModel> obj = new TableRowSorter<>(model);
        tableData.setRowSorter(obj);
        obj.setRowFilter(RowFilter.regexFilter(text1.getText()));
    }


```
<br> <br>
**JList :** The object of JList class represents a list of text items. The list of text items can be set up so that the user can choose either one item or multiple items. 
<br>
**Important Point from JList :**
```bash
// Event Listener : ListSelectionListener 
<br>
// Registration method1 : list1.addListSelectionListener(ListSelectionListener a)

//Override method1:

public void valueChanged(ListSelectionEvent e){
if(list1.getSelectedValue()== "A"){}
}
// Default List Model

DefaultListModel <String> l1 = new DefaultListModel <> ();
JList <String> list = new JList <> ();
// method to add element to list:
l1.addElement("hello");

// method to know which element is Selected:
if(list.getSelectedIndex()== 0){}

```

# JScrollBar
The object of JScrollbar class is used to add horizontal and vertical scrollbar.
<br>
Syntax :
JScrollBar s=new JScrollBar(); 

# JScrollPane :
A JscrollPane is used to make scrollable view of a component. When screen size is limited, we use a scroll pane to display a large component or a component whose size can change dynamically.


<br>

We can use JScrollPane in textarea and table .
<br>

```bash
JScrollPane scrollableTextArea = new JScrollPane(textArea);

JScrollPane scrollableTextArea = new JScrollPane(table);

// set the properties of JScrollPane 
table.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);  
table.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);  
```

# JPanel 
The JPanel is a simplest container class. It provides space in which an application can attach any other component.
<br>
we can add JPanel to JFrame and can set its background color.
<br>
```bash
JFrame frame = new JFrame();
JPanel panel = new JPanel();
panel.setBackground(Color.yellow);
frame.add(panel);
```
# JFrame :

**How to set the background color in swing JFrame**  
<br>
 frame.getContentPane().setBackground(Color.YELLOW);  

getContentPane() => A container has several layers in it. We can think of a layer as a transparent film that overlays the container. In Java Swing, the layer that is used to hold objects is called the content pane. Objects are added to the content pane layer of the container. The getContentPane() method retrieves the content pane layer so that you can add an object or apply method to it. The content pane is an object created by the Java run time environment. 
**Remember that Content Pane is a layer of container.**

<br>

**How to use SetBounds(x-axis , y- axis , width, height)**
<br>
Remember that in swing or awt gui, the origin start from top left . 

![image](https://github.com/RupeshKumar4511/Java-Programming-code/assets/149661006/f4a9bffb-82d1-46c3-9184-9fdde918a525)



 






















